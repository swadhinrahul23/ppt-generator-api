"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hyperlink = void 0;
const xml_helper_1 = require("../helper/xml-helper");
const shape_1 = require("../classes/shape");
const modify_hyperlink_helper_1 = __importDefault(require("../helper/modify-hyperlink-helper"));
const general_helper_1 = require("../helper/general-helper");
class Hyperlink extends shape_1.Shape {
    constructor(shape, targetType, sourceArchive, hyperlinkType = 'external', hyperlinkTarget) {
        super(shape, targetType);
        this.sourceArchive = sourceArchive;
        this.hyperlinkType = hyperlinkType;
        this.hyperlinkTarget = hyperlinkTarget || '';
        this.relRootTag = 'a:hlinkClick';
        this.relAttribute = 'r:id';
    }
    modify(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare(targetTemplate, targetSlideNumber);
            yield this.setTargetElement();
            yield this.editTargetHyperlinkRel();
            yield this.replaceIntoSlideTree();
            // Get the slide relations XML to pass to callbacks
            const slideRelXml = yield this.getRelationsElement();
            // Pass both the element and the relation to applyCallbacks
            // Use the documentElement property to get the root element of the XML document
            this.applyCallbacks(this.callbacks, this.targetElement, slideRelXml);
            return this;
        });
    }
    append(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare(targetTemplate, targetSlideNumber);
            yield this.setTargetElement();
            yield this.appendToSlideTree();
            const slideRelXml = yield this.getRelationsElement();
            modify_hyperlink_helper_1.default.addHyperlink(this.hyperlinkTarget, this.hyperlinkType === 'internal')(this.targetElement, slideRelXml);
            return this;
        });
    }
    remove(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare(targetTemplate, targetSlideNumber);
            if (this.target && this.target.rId) {
                this.sourceRid = this.target.rId;
            }
            const slideRelXml = yield this.getRelationsElement();
            modify_hyperlink_helper_1.default.removeHyperlink()(this.targetElement, slideRelXml);
            yield this.removeFromSlideTree();
            return this;
        });
    }
    getRelationsElement() {
        return __awaiter(this, void 0, void 0, function* () {
            const slideRelXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, this.targetSlideRelFile);
            return slideRelXml.documentElement;
        });
    }
    prepare(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setTarget(targetTemplate, targetSlideNumber);
            if (!this.createdRid) {
                const baseId = yield xml_helper_1.XmlHelper.getNextRelId(this.targetArchive, this.targetSlideRelFile);
                this.createdRid = baseId.endsWith('-created')
                    ? baseId.slice(0, -8)
                    : baseId;
            }
            if (this.shape && this.shape.target && this.shape.target.rId) {
                this.sourceRid = this.shape.target.rId;
            }
            if (!this.hyperlinkTarget &&
                this.shape &&
                this.shape.target &&
                this.shape.target.file) {
                this.hyperlinkTarget = this.shape.target.file;
                this.hyperlinkType = this.determineHyperlinkType(this.shape.target);
            }
        });
    }
    determineHyperlinkType(target) {
        return target.isExternal ||
            target.type ===
                'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink'
            ? 'external'
            : 'internal';
    }
    editTargetHyperlinkRel() {
        return __awaiter(this, void 0, void 0, function* () {
            const isExternalLink = this.hyperlinkType === 'external';
            const rels = yield this.getRelationsElement();
            modify_hyperlink_helper_1.default.setHyperlinkTarget(this.hyperlinkTarget, isExternalLink)(this.targetElement, rels);
        });
    }
    static getAllOnSlide(archive, relsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const hyperlinkRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';
            const slideRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide';
            return xml_helper_1.XmlHelper.getRelationshipItems(archive, relsPath, (element, rels) => {
                const type = element.getAttribute('Type');
                if (type === hyperlinkRelType || type === slideRelType) {
                    rels.push({
                        rId: element.getAttribute('Id'),
                        type: element.getAttribute('Type'),
                        file: element.getAttribute('Target'),
                        filename: element.getAttribute('Target'),
                        element: element,
                        isExternal: element.getAttribute('TargetMode') === 'External' ||
                            type === hyperlinkRelType,
                    });
                }
            });
        });
    }
    modifyOnAddedSlide(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.target || !this.target.rId) {
                general_helper_1.Logger.log('modifyOnAddedSlide called on Hyperlink without a valid source target/rId.', 2);
                return;
            }
            this.sourceRid = this.target.rId;
            this.hyperlinkTarget = this.target.file;
            this.hyperlinkType = this.determineHyperlinkType(this.target);
            yield this.prepare(targetTemplate, targetSlideNumber);
            yield this.editTargetHyperlinkRel();
        });
    }
    static addHyperlinkToShape(archive, slidePath, slideRelsPath, shapeId, hyperlinkTarget) {
        return __awaiter(this, void 0, void 0, function* () {
            const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, slidePath);
            const shape = xml_helper_1.XmlHelper.isElementCreationId(shapeId)
                ? xml_helper_1.XmlHelper.findByCreationId(slideXml, shapeId)
                : xml_helper_1.XmlHelper.findByName(slideXml, shapeId);
            if (!shape) {
                throw new Error(`Shape with ID/name "${shapeId}" not found`);
            }
            const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, slideRelsPath);
            modify_hyperlink_helper_1.default.addHyperlink(hyperlinkTarget, typeof hyperlinkTarget === 'number')(shape, relXml.firstChild);
            xml_helper_1.XmlHelper.writeXmlToArchive(archive, slideRelsPath, relXml);
            xml_helper_1.XmlHelper.writeXmlToArchive(archive, slidePath, slideXml);
            return yield xml_helper_1.XmlHelper.getNextRelId(archive, slideRelsPath);
        });
    }
}
exports.Hyperlink = Hyperlink;
//# sourceMappingURL=hyperlink.js.map